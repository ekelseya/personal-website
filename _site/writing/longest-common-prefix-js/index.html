<!DOCTYPE html> 
<html lang="en"> 
<head> 
  <meta charset="utf-8"> 
  <meta name="viewport" content="width=device-width, initial-scale=1" /> 
  <title>Longest Common Prefix</title> 

  <link rel="preconnect" href="https://fonts.gstatic.com">
  <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono&family=Roboto:ital,wght@0,400;0,500;0,700;1,400;1,500;1,700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="/css/styles.css">
</head> 

<body>
  <nav class="main-menu" aria-label="Main Menu" role="navigation">
    <a class="skip-link" href='#main'>Skip to content</a>

    <div id="burger" tabindex="0" aria-label"Select for Main Menu">
      <span></span>
    </div>

    <div id="menu">

      <ul class="nav-items"> 
        <li><a href="/">
            <svg id="logo" width="24" height="24" xmlns="http://www.w3.org/2000/svg" fill-rule="evenodd" clip-rule="evenodd"><path d="M12.447 24h-.894c-.235 0-.461-.079-.616-.218l-1.187-.782h4.5l-1.188.782c-.154.139-.38.218-.615.218zm1.845-2h-4.558c-.276 0-.5-.223-.5-.5 0-.276.224-.5.5-.5h4.558c.276 0 .5.224.5.5 0 .277-.224.5-.5.5zm.494-2h-5.572c0-3.949-3.214-5.659-3.214-9.228 0-3.723 2.998-5.772 5.997-5.772 3.001 0 6.003 2.052 6.003 5.772 0 3.569-3.214 5.224-3.214 9.228zm-2.789-9l.75-3h-2l-1.26 5h2.505l-.75 3h2l1.245-5h-2.49zm7.742 1.771l2.699 1.224-.827 1.822-2.596-1.177c.301-.6.55-1.215.724-1.869zm-15.477 0c.173.664.415 1.261.719 1.87l-2.592 1.176-.827-1.822 2.7-1.224zm18.738-1.771h-3.003c.021-.67-.04-1.345-.185-2h3.188v2zm-18.997 0h-3.003v-2h3.187c-.143.654-.203 1.326-.184 1.995v.005zm14.04-5.428l2.485-1.763 1.158 1.631-2.505 1.777c-.292-.582-.67-1.132-1.138-1.645zm-12.087-.001c-.46.503-.837 1.05-1.138 1.645l-2.503-1.776 1.157-1.631 2.484 1.762zm8.869-2.092l1.327-2.69 1.793.885-1.327 2.69c-.557-.367-1.161-.664-1.793-.885zm-5.651-.002c-.631.22-1.236.516-1.794.884l-1.326-2.687 1.794-.885 1.326 2.688zm3.826-.416c-.668-.078-1.309-.082-2-.003v-3.058h2v3.061z"/></svg>
            <span>E Kelsey A</span></a>
        <li><a class="nav__item 
                  " 
              aria-current="false"
              href="/">Home</a>
        </li>      
        <li>
          <a class="nav__item current" aria-current="true" href="/writing">writing</a>
        </li>
        <li>
          <a class="nav__item " aria-current="false" href="/reading">Reading</a>
        </li>
        <li>
          <a class="nav__item " aria-current="false" href="/building">Building</a>
        </li>
        <li>
          <a class="nav__item " aria-current="false" href="/watching">Watching</a>
        </li>
        <li>
          <a class="nav__item " aria-current="{ 'true' if '/listening' in page.url else 'false' }}" href="/listening">Listening</a>
        </li>
        <li>
          <button id="dark-toggle" class="btn btn-toggle" title="Toggle Dark Mode">
            <svg id="moon" class="hidden" aria-hidden="true" focusable="false" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path d="M12 10.999c1.437.438 2.562 1.564 2.999 3.001.44-1.437 1.565-2.562 3.001-3-1.436-.439-2.561-1.563-3.001-3-.437 1.436-1.562 2.561-2.999 2.999zm8.001.001c.958.293 1.707 1.042 2 2.001.291-.959 1.042-1.709 1.999-2.001-.957-.292-1.707-1.042-2-2-.293.958-1.042 1.708-1.999 2zm-1-9c-.437 1.437-1.563 2.562-2.998 3.001 1.438.44 2.561 1.564 3.001 3.002.437-1.438 1.563-2.563 2.996-3.002-1.433-.437-2.559-1.564-2.999-3.001zm-7.001 22c-6.617 0-12-5.383-12-12s5.383-12 12-12c1.894 0 3.63.497 5.37 1.179-2.948.504-9.37 3.266-9.37 10.821 0 7.454 5.917 10.208 9.37 10.821-1.5.846-3.476 1.179-5.37 1.179z"/></svg>
              <title>Toggle Dark Mode</title>
              <path d="M0 12c0 6.627 5.373 12 12 12s12-5.373 12-12-5.373-12-12-12-12 5.373-12 12zm2 0c0-5.514 4.486-10 10-10v20c-5.514 0-10-4.486-10-10z"/></svg>
            <svg id="sun" aria-hidden="true" focusable="false" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24">
              <title>Toggle Dark Mode</title>
              <path d="M22.088 13.126l1.912-1.126-1.912-1.126c-1.021-.602-1.372-1.91-.788-2.942l1.093-1.932-2.22-.02c-1.185-.01-2.143-.968-2.153-2.153l-.02-2.219-1.932 1.093c-1.031.583-2.34.233-2.941-.788l-1.127-1.913-1.127 1.913c-.602 1.021-1.91 1.372-2.941.788l-1.932-1.093-.02 2.219c-.01 1.185-.968 2.143-2.153 2.153l-2.22.02 1.093 1.932c.584 1.032.233 2.34-.788 2.942l-1.912 1.126 1.912 1.126c1.021.602 1.372 1.91.788 2.942l-1.093 1.932 2.22.02c1.185.01 2.143.968 2.153 2.153l.02 2.219 1.932-1.093c1.031-.583 2.34-.233 2.941.788l1.127 1.913 1.127-1.913c.602-1.021 1.91-1.372 2.941-.788l1.932 1.093.02-2.219c.011-1.185.969-2.143 2.153-2.153l2.22-.02-1.093-1.932c-.584-1.031-.234-2.34.788-2.942zm-10.117 6.874c-4.411 0-8-3.589-8-8s3.588-8 8-8 8 3.589 8 8-3.589 8-8 8zm.029-12c2.206 0 4 1.794 4 4s-1.794 4-4 4v-8zm0-2c-3.313 0-6 2.687-6 6s2.687 6 6 6 6-2.687 6-6-2.687-6-6-6z"/></svg>
            <span class="sr-only">Click to toggle dark and light mode</span>
          </button>
        </li>
      </ul> 


    </div>
  </nav>

  <header>
    
    
    
    
    
      
    

  
    
      <nav class="breadcrumbs" aria-label="breadcrumbs" role="navigation">
        <a href="/">Home</a> 
        
          
        
          
            &#187; <a href="/writing">Writing</a>
          
        
        
        
          &#187; Longest Common Prefix
        
      </nav>
      <hr>
    
  </header>
 
  <main id="main">
    <article>
        <h1>Longest Common Prefix</h1>
        <div class="added">Added <time datetime="2021-01-15T00:22:35.406Z">January 15, 2021</time></div>
        <h2>Given an array of strings, like [&quot;concentrate&quot;, &quot;concatenate&quot;, &quot;conman&quot;], how do you find the longest common prefix, in this case &quot;con&quot;? Let's use ALL THE LOOPS!</h2>
<p>The <a href="https://leetcode.com/problems/longest-common-prefix/">Longest Common Prefix</a> problem on <a href="https://leetcode.com/">LeetCode</a> states:</p>
<hr>
<p>Write a function to find the longest common prefix string amongst an array of strings.</p>
<p>If there is no common prefix, return an empty string &quot;&quot;.</p>
<p>Example 1:</p>
<p>Input: strs = [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]<br>
Output: &quot;fl&quot;</p>
<p>Example 2:</p>
<p>Input: strs = [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]<br>
Output: &quot;&quot;<br>
Explanation: There is no common prefix among the input strings.</p>
<p>Constraints:</p>
<p>0 &lt;= strs.length &lt;= 200<br>
0 &lt;= strs[i].length &lt;= 200<br>
strs[i] consists of only lower-case English letters.<br></p>
<hr>
<h2>Slice</h2>
<p>This is a pretty straight forward problem when we use JavaScript's built in slice function.</p>
<pre><code>function longestCommonPrefix(strs) {
    if (strs.length === 0) return '';
    const first = strs[0];

    for (let i = 0; i &lt; first.length; i++) {
        for (let j = 1; j &lt; strs.length; j++) {
            const next = strs[j];
            if (next[i] !== first[i]) {
                return next.slice(0, i);
            }
        }
    }

    return first;
}
</code></pre>
<h3>Breaking it down line by line</h3>
<p>Wow. That's a lot of loops!</p>
<p>First I declare the function:</p>
<pre><code>function longestCommonPrefix(strs) {

}
</code></pre>
<p>I'm using the tried and true function declaration, but this could easily be a function expression. The only real difference is the scope.</p>
<p>Next let's check that edge case: when <code>strs</code> is an empty array:</p>
<pre><code>if (strs.length === 0) return '';
</code></pre>
<p>If <code>strs</code> has no strings to compare, exit the function immediately and return an empty string.</p>
<p>Time to set up the nested loops. First I need something to compare to.</p>
<pre><code>const first = strs[0];
</code></pre>
<p>I assign the first string in <code>strs</code> to a constant imaginatively called <code>first</code>. I think it's important to give variables meaningful names.</p>
<h4>Const versus Let</h4>
<p>Prior to ES6, JavaScript used <code>var</code> to declare variables, whether they were constant or not. ES6 introduced <code>const</code> and <code>let</code>. What's the difference?</p>
<p>Var had function scope - it was available inside the function where it was defined.</p>
<p>Let has block scope. It's similar to function scope but even more narrowly defined - block scope is anything in between curly braces {} - functions, if statements, for loops, et cetera. Let can only be declared once, but it can be reassigned as many times as your heart desires.</p>
<p>Const has block scope too, but it cannot be reassigned. Once it's assigned a value, that value is constant.</p>
<p>Another main difference between the old <code>var</code> and the new <code>const</code> and <code>let</code> are hoisting. It's important to realize JavaScript differentiates between variable assignment and declaration.</p>
<pre><code>var myVar; // This is the declaration

myVar = &quot;I'm out of date&quot;; // This is the assignment 

const myConst = &quot;I'm a const&quot;; 
// This is the declaration and assignment on one line
</code></pre>
<p>All three are hoisted at initialization. The old var was initialized at declaration (<code>var</code> was initialized as undefined). Const and let are initialized when assigned a value. In fact a <code>const</code> must be initialized when declared. You cannot use a <code>let</code> variable before its declaration is reached. If you try, you will get a ReferenceError.</p>
<p>Why did I choose to make <code>first</code> a <code>const</code>? Personal choice. I won't be reassigning it, so why not? Would it affect the code if it were a <code>let</code>? No, but I could potentially accidentally reassign it later on, and that could be bad.</p>
<h4>Nested For Loops</h4>
<p>Now that I have everything set up, it's time to start comparing strings. When I first started coding, I had some trouble keeping track of nested for loops. I found talking through what happens at each step helped the most.</p>
<pre><code>for (let i = 0; i &lt; first.length; i++) {

}
</code></pre>
<p>First I want to step through each character in the first string. I initialize an index, set its max as the length of <code>first</code>, and then increment through each character.</p>
<p>Now that I have the first string, I need to compare it to the other strings.</p>
<pre><code>for (let j = 1; j &lt; strs.length; j++) {
    const next = strs[j];
}
</code></pre>
<p>Again, a simple for loop, but this time I am looping through each string in the original array of strings. I initialize a <code>const</code> as the second string in the array <code>strs</code> (note that <code>j</code> is initialized to 1). Because of const's block scope, I can use it here, even though I will be looping through the code multiple times. Every time this block ends, <code>next</code> is reinitialized.</p>
<p>Now I have two strings to compare, I can isolate the first character of each and compare.</p>
<pre><code>if (next[i] !== first[i]) {
    return next.slice(0, i);
}
</code></pre>
<p>If first[i] and next[i] are equal, I just want to keep looping. If they do not equal each other, I need to exit the entire function. The return statement makes use of JavaScript's slice method.</p>
<h4>Slice</h4>
<p>According to the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/slice">MDN docs</a>, the slice function slices out a part of a string and returns it as a new string, without modifying the original. The synatx is:</p>
<pre><code>str.slice(beginIndex[, endIndex])
</code></pre>
<p><code>beginIndex</code> is the (zero-based) index to start the slice. It is inclusive:</p>
<pre><code>const str = &quot;string&quot;;
str.slice(2);

// Returns &quot;ring&quot;
</code></pre>
<p><code>endIndex</code> is optional. It is the (zero-based) index to end the slice. It is <strong>exclusive</strong>:</p>
<pre><code>const str = &quot;string&quot;;
str.slice(2, 3);

// Returns &quot;r&quot;
</code></pre>
<p>In my code,</p>
<pre><code>return next.slice(0, i);
</code></pre>
<p>the slice returns all of the characters prior to the first non-matching character.</p>
<p>Finally we need to catch the other edge case; when all the strings in the array are equal. If we step through every character of every string and never hit the inner return statemnt, we simply return the first string in the array.</p>
<h4>Stepping through the loops</h4>
<p>Let's pretend to be the computer and work through the loops. Our starting array <code>strs</code> will be [&quot;cat&quot;, &quot;can&quot;, &quot;cool&quot;].</p>
<pre><code>function longestCommonPrefix(strs) {
    if (strs.length === 0) return '';
    const first = strs[0];

    for (let i = 0; i &lt; first.length; i++) {
        for (let j = 1; j &lt; strs.length; j++) {
            const next = strs[j];
            if (next[i] !== first[i]) {
                return next.slice(0, i);
            }
        }
    }

    return first;
}
</code></pre>
<p>The first check is for an empty array. This array has three elements, so we move on.</p>
<p>Next we initialize the const <code>first</code> to the first string in our array (&quot;cat&quot;).</p>
<p>In our first loop, we need to move through each character of &quot;cat&quot;. The index counter, <code>i</code>, is initialized to 0.</p>
<p>Now we step into our second loop. Here we need to grab the next string in the array, &quot;can&quot;. We initialize a counter for the index of the array, call it <code>j</code>, to 1. <code>str[1]</code> is &quot;can&quot;. We assign it to the const <code>next</code>.</p>
<p>Now we can compare characters in the string. If the first characters match (<code>first[0]</code> and <code>next[0]</code>), we hit the end of the inner loop. Our array index counter is incremented (<code>j++</code>) and we grab the next string in our array, &quot;cool&quot; and compare its first character to the first character of our first string, &quot;cat&quot;. They both start with c, so we increment <code>j</code> again. But this time <code>j</code> equals 3, which is no longer less than the length of the array <code>strs</code>. We end the inner loop.</p>
<p>Back to the outer loop, <code>i</code> is incremented to 1. We repeat the same inner loop process as before. &quot;cat&quot; and &quot;can&quot; both have the same second character, but when we get to &quot;cool&quot; the if statement is triggered: &quot;o&quot; is not equal to &quot;a&quot; so we return everything that matched prior: <code>next.slice(0, i)</code>. Remember that the <code>endIndex</code> is exclusive; it is not returned as part of the new string.</p>
<p>You can see the function in action on my <a href="https://repl.it/@ekelseya/LongestCommonPrefix#index.js">repl</a>.</p>
<h3>Complexity Analysis</h3>
<p>Time complexity: O(n<sup>2</sup>)<br>
Space complexity: O(1)</p>
<p>A nested loop is always O(n<sup>2</sup>) (technically it's 1/2 O(n<sup>2</sup>) but we can drop the constant). We only use and reuse a few primitive variables so space complexity is O(1).</p>

    </article>
  </main> 


<footer>
  

  <hr>

  <div class="contact-icons">
    <a href="https://github.com/ekelseya" aria-label="My Github Profile.">
      <svg class="github" xmlns="http://www.w3.org/2000/svg" width="48" height="48" viewBox="0 0 24 24">
      <title>My Github Profile</title>
      <path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"/></svg>
    </a>
    <a href="https://www.linkedin.com/in/eryn-kelsey-adkins-6559651b2/" aria-label="My LinkedIn Profile.">
      <svg class="linkedin" xmlns="http://www.w3.org/2000/svg" width="48" height="48" viewBox="0 0 24 24">
        <title>My LinkedIn Profile</title>
      <path d="M12 2c5.514 0 10 4.486 10 10s-4.486 10-10 10-10-4.486-10-10 4.486-10 10-10zm0-2c-6.627 0-12 5.373-12 12s5.373 12 12 12 12-5.373 12-12-5.373-12-12-12zm-2 8c0 .557-.447 1.008-1 1.008s-1-.45-1-1.008c0-.557.447-1.008 1-1.008s1 .452 1 1.008zm0 2h-2v6h2v-6zm3 0h-2v6h2v-2.861c0-1.722 2.002-1.881 2.002 0v2.861h1.998v-3.359c0-3.284-3.128-3.164-4-1.548v-1.093z"/></svg>
    </a>
    <a href="https://twitter.com/ekelseya" aria-label="Find me on Twitter.">
      <svg class="twitter" xmlns="http://www.w3.org/2000/svg" width="48" height="48" viewBox="0 0 24 24">
        <title>Find me on Twitter</title>
      <path d="M12 0c-6.627 0-12 5.373-12 12s5.373 12 12 12 12-5.373 12-12-5.373-12-12-12zm6.066 9.645c.183 4.04-2.83 8.544-8.164 8.544-1.622 0-3.131-.476-4.402-1.291 1.524.18 3.045-.244 4.252-1.189-1.256-.023-2.317-.854-2.684-1.995.451.086.895.061 1.298-.049-1.381-.278-2.335-1.522-2.304-2.853.388.215.83.344 1.301.359-1.279-.855-1.641-2.544-.889-3.835 1.416 1.738 3.533 2.881 5.92 3.001-.419-1.796.944-3.527 2.799-3.527.825 0 1.572.349 2.096.907.654-.128 1.27-.368 1.824-.697-.215.671-.67 1.233-1.263 1.589.581-.07 1.135-.224 1.649-.453-.384.578-.87 1.084-1.433 1.489z"/></svg>
    </a>
    <a href="mailto:ekelseya@gmail.com" aria-label="Email me.">
      <svg class="email" xmlns="http://www.w3.org/2000/svg" width="48" height="48" viewBox="0 0 24 24">
        <title>Email me</title>
      <path d="M12 .02c-6.627 0-12 5.373-12 12s5.373 12 12 12 12-5.373 12-12-5.373-12-12-12zm6.99 6.98l-6.99 5.666-6.991-5.666h13.981zm.01 10h-14v-8.505l7 5.673 7-5.672v8.504z"/></svg>
    </a>
  </div>
</footer>

<script src="/js/script.js"></script>

</body>

</html>